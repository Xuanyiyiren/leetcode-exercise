解法是很简单的双指针法。

- 先写一个找到链表中的第一个非零元素的节点并且释放前面所有节点的函数 `ListNode* FristNonZero(ListNode *head)`，如果列表全是 0 （一直往后找到底了），就返回空指针。这在后面很有用
- 先将头节点初始化为第一个非零值。如果全是零，头节点被初始化为空指针，此时直接返回空指针。然后 p 指针赋值为头指针，q 指针赋值为头指针的下一位。
- q 指针依次往后遍历，知道 q 遍历到尾部（判断是否为空指针）
  - 如果遇到非零，就加到 p 指针的值上去，并且释放该节点且q继续往后移位（这里必须借助额外的指针实现）。
  - 如果遇到0，就先预存下 p 的位置，将 q 作为头节点，借助 `FristNonZero` 往后找到第一个非零节点，将其赋值给 p ，并且原来的 p （被预存的）指向该节点，然后 q 赋值给 p 的下一位，继续循环



第一次用 C++ 写，写的太菜还见谅