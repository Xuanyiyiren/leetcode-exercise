解法是很简单的双指针法。

- 先写一个找到链表中的第一个非零元素的节点并且释放前面所有节点的函数 `ListNode* FristNonZero(ListNode *head)`，如果列表全是 0 （一直往后找到底了），就返回空指针。这在后面很有用
- 先将头节点初始化为第一个非零值。如果全是零，头节点被初始化为空指针，此时直接返回空指针。然后 p 指针赋值为头指针，q 指针赋值为头指针的下一位。
- q 指针依次往后遍历，直到 q 遍历到尾部（判断是否为空指针，但这个条件好像没用）
  - 如果遇到非零，就加到 p 指针的值上去，并且释放该节点且q继续往后移位（这里必须借助额外的指针实现）。
  - 如果遇到0，就先预存下 p 的位置，将 q 作为头节点，借助 `FristNonZero` 往后找到第一个非零节点
    - 如果成功找到，将其赋值给 p ，并且原来的 p （被预存的）指向该节点，然后 q 赋值给 p 的下一位，继续循环
    - 如果找不到，说明此时 q 往后都是 0 ，于是预存的 p 后面指向空指针，释放掉 q 后面的 0，返回结果即可



第一次用 C++ 写，写的太菜还见谅。

感觉 leetcode 对 C++ 不太友好呀，首先 C++ 本地测试有点麻烦，导入示例写测试什么的都有点麻烦，好在借助适合的Makefile模板都不是问题。然后就是动态内存管理，如果做好废弃地址释放，必然会降低程序速度，所以提升速度的一个方法是不做内存释放，空间换时间。

上面是人菜瘾大的一些错误言论，欢迎大家指正。